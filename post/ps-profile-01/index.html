<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Modular PowerShell Profile - Part 1 of 2 | Beli's blog</title>
<meta name=keywords content="powershell,guide,tools,pwsh,code"><meta name=description content="Simplify Your Workflow, Detailed guide to setting up a Flexible PowerShell Profile"><meta name=author content="Manjunath Beli"><link rel=canonical href=https://blog.belibug.com/post/ps-profile-01/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.belibug.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.belibug.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.belibug.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.belibug.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.belibug.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.belibug.com/post/ps-profile-01/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-EKBBBJE5PX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EKBBBJE5PX")}</script><meta property="og:title" content="Building a Modular PowerShell Profile - Part 1 of 2"><meta property="og:description" content="Simplify Your Workflow, Detailed guide to setting up a Flexible PowerShell Profile"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.belibug.com/post/ps-profile-01/"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-07-26T00:00:00+00:00"><meta property="og:site_name" content="Beli's Blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Modular PowerShell Profile - Part 1 of 2"><meta name=twitter:description content="Simplify Your Workflow, Detailed guide to setting up a Flexible PowerShell Profile"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.belibug.com/post/"},{"@type":"ListItem","position":2,"name":"Building a Modular PowerShell Profile - Part 1 of 2","item":"https://blog.belibug.com/post/ps-profile-01/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Modular PowerShell Profile - Part 1 of 2","name":"Building a Modular PowerShell Profile - Part 1 of 2","description":"Simplify Your Workflow, Detailed guide to setting up a Flexible PowerShell Profile","keywords":["powershell","guide","tools","pwsh","code"],"articleBody":"The PowerShell profile is the unsung hero of your shell, a secret weapon that can transform your mundane tasks into an efficiency and fun excercise.\nIf your PowerShell usage is confined to executing one-liners or running scripts from shared folders within the outdated ISE, you‚Äôre missing out on a world of customization and efficiency.\nThis is the first part of a two-part series where we‚Äôll dive deep into the world of profile customization. Get ready to discover a treasure trove of tips and tricks that‚Äôll elevate your PowerShell experience to legendary status. ‚ú®\nüîß Essential Setup This guide is optimized for PowerShell 7. If you‚Äôre still clinging to an older version, I highly recommend upgrading to the latest and greatest for the optimal experience.\nOptional Pro Tip: For Windows users, consider installing the Windows Terminal or any other modern terminal that boasts rich ANSI support. This will enhance the visual appeal and functionality of your PowerShell environment. Mac and Linux users typically have this capability built into their terminals already (mostly).\nüìù Crafting Your PowerShell Profile If you‚Äôre a PowerShell profile newbie, no worries! We‚Äôll start from scratch. Just fire up your terminal and execute the following code:\nif (!(Test-Path -Path $PROFILE)) { New-Item -ItemType File -Path $PROFILE -Force } # Open in Default editor, choose notepad if you are prompted to select one Invoke-Item $PROFILE This nifty snippet will create your profile file if it doesn‚Äôt already exist and open it in your default text editor. Easy peasy!\nüß© Building Blocks of Your Profile To keep your profile tidy, maintainable, and efficient, I‚Äôve categorized the components into distinct groups. While you don‚Äôt have to incorporate every single element, understanding the possibilities and loading mechanisms is key to unleashing the full potential of your PowerShell profile.\nLet‚Äôs explore each component in detail. In the next article (Part 2 of 2), I‚Äôll guide you through assembling these building blocks to create a powerhouse profile that‚Äôs tailored to your unique needs.\nüé® Prompt Makeover: Let Your Personality Shine Through One of the most obvious signs that someone has leveled up their PowerShell game is a personalized prompt. The default prompt might suffice for a quick virtual machine session, but why settle for mediocrity when you can have a prompt that‚Äôs as unique as you are?\nBelow is the basic Default prompt, its not too bad, but we can easily enhance it.\nLet‚Äôs inject some life into your terminal with this simple yet eye-catching prompt function,\nfunction prompt { $curPath = (Get-Location).Path $curTime = Get-Date -Format 'HH:mm:ss' Write-Host $curPath -ForegroundColor Red -NoNewline Write-Host ' :: ' -NoNewline Write-Host $curTime -ForegroundColor Blue -NoNewline Write-Host ' ‚ö°' -NoNewline return ' ' } This function replaces the bland default prompt with a stylish colorful prompt with path, time and classic thunder emoji. Feel free to customize and experiment with different prompt and make it truly yours.\nPrompt Pro Tip: This is just a taste of the incredible prompt customization possibilities at your fingertips! Dive into Microsoft‚Äôs about_Prompts documentation to uncover a wealth of additional options.\nIf you‚Äôre looking for ready-made prompt awesomeness, consider exploring popular modules like Oh My Posh or binaries like Starship. These tools offer a vast array of pre-designed prompts that can instantly elevate your PowerShell style.\nBeyond the prompt, you can personalize your PowerShell experience even further by customizing fonts, font sizes, backgrounds, themes, and other visual elements. These settings vary depending on your terminal app and are typically accessible through its configuration or settings page.\nüîÄ Alias Wizardry: PowerShell Shortcuts Aliases are the bread and butter of any shell configuration, and PowerShell is no exception. While PowerShell handles aliases in its own unique way (either within functions/scripts or as manual creations), the concept remains the same, create shortcuts to frequently used commands for a smoother workflow.\nDiscovering Existing Aliases Before diving into custom aliases, familiarize yourself with the built-in aliases that PowerShell provides. Many common Linux-style commands already have aliases defined, so you might discover that the shortcut you need is already at your disposal.\n# Get all alias in the current session] Get-Alias Creating Your Own Aliases Setting aliases is a breeze with the Set-Alias command. For instance, to create a handy shortcut like date for the Get-Date command, simply execute:\n# Set Alias Set-Alias -Name date -Value Get-Date Advanced Alias Techniques: Functions as Aliases But what if you crave a date in a different format, with little more customization that is not offered by native command?\nThe preferred way is to create a function that wraps into a function, this provides the most customziation options.\nfunction sdate { (Get-Date).ToShortDateString() } Tab Completion: The Alias Alternative While aliases are undoubtedly handy for saving keystrokes, I‚Äôm a firm believer in the power of tab completion. Luckily, PowerShell has this feature built right in, so there‚Äôs no need for any extra plugins. The more you use PowerShell, the more tab completion will become an instinctive part of your workflow.\nIn the date example, instead of setting an alias, it‚Äôs far more efficient to simply type Get-D and hit the Tab key. PowerShell will magically complete the command to Get-Date for you!\nThis approach not only saves you from memorizing aliases but also empowers you to explore the full range of available commands with ease. It‚Äôs a win-win!\nNote: Remember, PowerShell is case-insensitive, so typing get-date and Get-Date produces the same result. I tend to avoid CamelCasing in the terminal, but tab completion swoops in to automatically convert the command to the appropriate case, ensuring my code remains clean and readable.\nüåç Environment Variables: Data Storage\nEnvironment variables are like the multi-purpose tools of your PowerShell Session. They can store a variety of information that can be used to customize your environment, control script behavior, and streamline your workflow. Storing confidential and private information in Env Variable isolates your data from the script. Here are some practical use cases:\nAPI Keys and Tokens Configuration Settings Paths PowerShell allows you to easily set env variable,\n$env:TOKEN = \"xyz-token-value\" $env:EDITOR = \"nvim\" Depending on your operating system, these variables can operate in system, user, or session contexts. Env variable set in PROFILE is confined to session context.\n‚ö°Ô∏è Supercharging with Modules With the basics in place, it‚Äôs time to inject some serious functionality into your shell using external Modules. Most PowerShell modules can be downloaded from PSGallery which has more than 13k unique packages.\nNote: Not all packages are build equal, take necessary precautions before you download any packages form external source.\nEvery module you add to your arsenal unlocks a new dimension of PowerShell capabilities. To kickstart your journey, here are some must-have modules that will instantly elevate your shell game:\nPSReadline: command line editing in the PowerShell console host PowerShellGet: Modern module manager oh-my-posh: Prompt enhancer Terminal-Icons: Show icons for files and folders Take PSReadLine, for instance. It‚Äôs not just a minor upgrade; it completely transforms your console experience with enhanced tab completion and customizable keybindings. Once you‚Äôve installed this powerhouse module, a simple configuration tweak unleashes its full potential: a list view prediction mode that blows the standard tab completion out of the water.\n# Assuming you have PSReadline Module installed Set-PSReadLineKeyHandler -Chord F2 -Function SwitchPredictionView Set-PSReadLineOption -EditMode Vi Screen-grab of psreadline prediction in list view. Source for prediction is history .\nüîç Completion for External Tools: Bridging the Gap\nA growing number of command-line interface (CLI) tools now offer completion support for PowerShell. This is a major win for productivity, as it eliminates the need to constantly refer to help menus or external documentation. With tab completion, these external tools seamlessly integrate into your PowerShell workflow, feeling almost as intuitive as native commands.\nTake the popular GitHub CLI, for instance. It‚Äôs a fantastic utility for interacting with GitHub repositories, issues, and pull requests right from your terminal. With completion support, you can effortlessly navigate its commands and options, making your Git-related tasks a breeze.\nThe GH-CLI comes with a built-in PowerShell completion script that you can access using gh completion --shell powershell. Integrating this script into your current terminal session is a straightforward process that unlocks tab completion for all the switches and parameters of the gh CLI tool.\n# Add gh completion helper to profile gh completion -s powershell | Out-String | Invoke-Expression ‚ú® Custom Functions: Sky is the limit As you progress on your PowerShell journey, your collection of custom functions will inevitably flourish. Resist the temptation to simply copy and paste functions from other sources.\nFor instance I have a simple function called Copy-Content. This small yet handy command has saved me ton of keystrokes and tremendously improved my productivity.\nfunction Copy-Content { param($Path) Get-Content $Path | Set-Clipboard } While you can certainly draw inspiration from others, let your own unique workflow and needs guide the growth of your function library.\nüöÄ Background Jobs: Supercharging without the Startup Lag Here‚Äôs a productivity trick that might not be in the PowerShell playbook, but it‚Äôs a game-changer for me.\nThere are certain tasks you might want to run periodically or on demand, like updating modules or fetching configuration files from a remote source. The conventional wisdom often points to scheduled tasks, which certainly work but operate outside your shell‚Äôs cozy environment.\nSince I practically live in the terminal, I prefer to set these tasks as background jobs directly within my PowerShell session. This allows me to manage and monitor them alongside my other PowerShell activities, keeping everything neatly centralized.\n‚ö†Ô∏è Important Note: Running these tasks as background jobs is essential. If you execute them directly within your profile, your profile‚Äôs load time will skyrocket, forcing you to wait for the tasks to finish every time you launch a new PowerShell session. Nobody wants that!\nBenefits of running it in profile and not as scheduled job It sits in $PROFILE as PowerShell code so its easy to modify (and version control) You can get status of the job at any point by running Get-Job On-Demand Execution, Trigger tasks manually by reloading your profile with . $PROFILE. Easy to manage and version control This is how I update one of the module ModuleFast (an epic module by Justin Grote)\n$sb = { Update-PSResource -Name ModuleFast } Start-Job -ScriptBlock $sb -Name ProfileJob This approach opens up a world of automation possibilities. You can delegate virtually any time-consuming task to your profile‚Äôs background jobs. I personally have an army of jobs working tirelessly behind the scenes, handling tasks like cleaning temp directory, Fetching Git Projects, Upgrading Modules and more.\nüéÅ Wrapping Up I have briefly explained each profile component and its role in improving Profile\nThis is just the beginning! In Part 2, we‚Äôll tackle profile management, organization, conditional loading and advanced techniques. Get ready to elevate your PowerShell game to the next level and make your shell truly your own.\n","wordCount":"1807","inLanguage":"en","datePublished":"2024-07-26T00:00:00Z","dateModified":"2024-07-26T00:00:00Z","author":{"@type":"Person","name":"Manjunath Beli"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.belibug.com/post/ps-profile-01/"},"publisher":{"@type":"Organization","name":"Beli's blog","logo":{"@type":"ImageObject","url":"https://blog.belibug.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.belibug.com/ accesskey=h title="Beli's blog (Alt + H)">Beli's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.belibug.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.belibug.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.belibug.com/>Home</a>&nbsp;¬ª&nbsp;<a href=https://blog.belibug.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Modular PowerShell Profile - Part 1 of 2</h1><div class=post-meta><span title='2024-07-26 00:00:00 +0000 UTC'>July 26, 2024</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;Manjunath Beli</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#-essential-setup>üîß <strong>Essential Setup</strong></a></li><li><a href=#-crafting-your-powershell-profile>üìù Crafting Your PowerShell Profile</a></li><li><a href=#-building-blocks-of-your-profile>üß© Building Blocks of Your Profile</a><ul><li><a href=#-prompt-makeover-let-your-personality-shine-through>üé® Prompt Makeover: Let Your Personality Shine Through</a></li><li><a href=#-alias-wizardry-powershell-shortcuts>üîÄ Alias Wizardry: PowerShell Shortcuts</a></li><li><a href=#-supercharging--with-modules>‚ö°Ô∏è Supercharging with Modules</a></li><li><a href=#-custom-functions-sky-is-the-limit>‚ú® Custom Functions: Sky is the limit</a></li><li><a href=#--background-jobs-supercharging-without-the-startup-lag>üöÄ Background Jobs: Supercharging without the Startup Lag</a></li></ul></li><li><a href=#-wrapping-up>üéÅ Wrapping Up</a></li></ul></nav></div></details></div><div class=post-content><p>The <strong>PowerShell profile</strong> is the unsung hero of your shell, a secret weapon that can transform your mundane tasks into an efficiency and fun excercise.</p><p>If your PowerShell usage is confined to executing one-liners or running scripts from shared folders within the outdated ISE, you&rsquo;re missing out on a world of customization and efficiency.</p><blockquote><p>This is the first part of a two-part series where we&rsquo;ll dive deep into the world of profile customization. Get ready to discover a treasure trove of tips and tricks that&rsquo;ll elevate your PowerShell experience to legendary status. ‚ú®</p></blockquote><h2 id=-essential-setup>üîß <strong>Essential Setup</strong><a hidden class=anchor aria-hidden=true href=#-essential-setup>#</a></h2><ul><li><p>This guide is optimized for PowerShell 7. If you&rsquo;re still clinging to an older version, I highly recommend upgrading to the latest and greatest for the optimal experience.</p></li><li><p>Optional Pro Tip: For Windows users, consider installing the Windows Terminal or any other modern terminal that boasts rich ANSI support. This will enhance the visual appeal and functionality of your PowerShell environment. Mac and Linux users typically have this capability built into their terminals already (mostly).</p></li></ul><h2 id=-crafting-your-powershell-profile>üìù Crafting Your PowerShell Profile<a hidden class=anchor aria-hidden=true href=#-crafting-your-powershell-profile>#</a></h2><p>If you&rsquo;re a PowerShell profile newbie, no worries! We&rsquo;ll start from scratch. Just fire up your terminal and execute the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=k>if</span> <span class=p>(!(</span><span class=nb>Test-Path</span> <span class=n>-Path</span> <span class=nv>$PROFILE</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nb>New-Item</span> <span class=n>-ItemType</span> <span class=n>File</span> <span class=n>-Path</span> <span class=nv>$PROFILE</span> <span class=n>-Force</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c># Open in Default editor, choose notepad if you are prompted to select one</span>
</span></span><span class=line><span class=cl><span class=nb>Invoke-Item</span> <span class=nv>$PROFILE</span>
</span></span></code></pre></div><p>This nifty snippet will create your profile file if it doesn&rsquo;t already exist and open it in your default text editor. Easy peasy!</p><h2 id=-building-blocks-of-your-profile>üß© Building Blocks of Your Profile<a hidden class=anchor aria-hidden=true href=#-building-blocks-of-your-profile>#</a></h2><p>To keep your profile tidy, maintainable, and efficient, I&rsquo;ve categorized the components into distinct groups. While you don&rsquo;t have to incorporate every single element, understanding the possibilities and loading mechanisms is key to unleashing the full potential of your PowerShell profile.</p><p>Let&rsquo;s explore each component in detail. In the next article (Part 2 of 2), I&rsquo;ll guide you through assembling these building blocks to create a powerhouse profile that&rsquo;s tailored to your unique needs.</p><h3 id=-prompt-makeover-let-your-personality-shine-through>üé® Prompt Makeover: Let Your Personality Shine Through<a hidden class=anchor aria-hidden=true href=#-prompt-makeover-let-your-personality-shine-through>#</a></h3><p>One of the most obvious signs that someone has leveled up their PowerShell game is a personalized prompt. The default prompt might suffice for a quick virtual machine session, but why settle for mediocrity when you can have a prompt that&rsquo;s as unique as you are?</p><p>Below is the basic <code>Default</code> prompt, its not too bad, but we can easily enhance it.</p><p><img loading=lazy src=./assets/image-20240609225812902.png alt=image-20240609225812902></p><p>Let&rsquo;s inject some life into your terminal with this simple yet eye-catching prompt function,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-PowerShell data-lang=PowerShell><span class=line><span class=cl><span class=kd>function</span><span class=w> </span><span class=nb>prompt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$curPath</span> <span class=p>=</span> <span class=p>(</span><span class=nb>Get-Location</span><span class=p>).</span><span class=py>Path</span>
</span></span><span class=line><span class=cl>    <span class=nv>$curTime</span> <span class=p>=</span> <span class=nb>Get-Date</span> <span class=n>-Format</span> <span class=s1>&#39;HH:mm:ss&#39;</span> 
</span></span><span class=line><span class=cl>    <span class=nb>Write-Host</span> <span class=nv>$curPath</span> <span class=n>-ForegroundColor</span> <span class=n>Red</span> <span class=n>-NoNewline</span>
</span></span><span class=line><span class=cl>    <span class=nb>Write-Host</span> <span class=s1>&#39; :: &#39;</span> <span class=n>-NoNewline</span>
</span></span><span class=line><span class=cl>    <span class=nb>Write-Host</span> <span class=nv>$curTime</span> <span class=n>-ForegroundColor</span> <span class=n>Blue</span> <span class=n>-NoNewline</span>
</span></span><span class=line><span class=cl>    <span class=nb>Write-Host</span> <span class=s1>&#39; ‚ö°&#39;</span> <span class=n>-NoNewline</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39; &#39;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><img loading=lazy src=./assets/image-20240609225916725.png alt=image-20240609225916725></p><p>This function replaces the bland default prompt with a stylish colorful prompt with path, time and classic thunder emoji. Feel free to customize and experiment with different prompt and make it truly yours.</p><blockquote><p><strong>Prompt Pro Tip:</strong> This is just a taste of the incredible prompt customization possibilities at your fingertips! Dive into Microsoft&rsquo;s <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_prompts?view=powershell-7.4">about_Prompts</a> documentation to uncover a wealth of additional options.</p></blockquote><p>If you&rsquo;re looking for ready-made prompt awesomeness, consider exploring popular modules like Oh My Posh or binaries like Starship. These tools offer a vast array of pre-designed prompts that can instantly elevate your PowerShell style.</p><p><img loading=lazy src=./assets/devious-diamonds-f628d7464031c6da757afea7bfa9f69c.png alt=devious-diamonds></p><p>Beyond the prompt, you can personalize your PowerShell experience even further by customizing fonts, font sizes, backgrounds, themes, and other visual elements. These settings vary depending on your terminal app and are typically accessible through its configuration or settings page.</p><h3 id=-alias-wizardry-powershell-shortcuts>üîÄ Alias Wizardry: PowerShell Shortcuts<a hidden class=anchor aria-hidden=true href=#-alias-wizardry-powershell-shortcuts>#</a></h3><p>Aliases are the bread and butter of any shell configuration, and PowerShell is no exception. While PowerShell handles aliases in its own unique way (either within functions/scripts or as manual creations), the concept remains the same, create shortcuts to frequently used commands for a smoother workflow.</p><h4 id=discovering-existing-aliases>Discovering Existing Aliases<a hidden class=anchor aria-hidden=true href=#discovering-existing-aliases>#</a></h4><p>Before diving into custom aliases, familiarize yourself with the built-in aliases that PowerShell provides. Many common Linux-style commands already have aliases defined, so you might discover that the shortcut you need is already at your disposal.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=c># Get all alias in the current session]</span>
</span></span><span class=line><span class=cl><span class=nb>Get-Alias</span>
</span></span></code></pre></div><p><img loading=lazy src=./assets/image-20240610234651744.png alt=image-20240610234651744></p><h4 id=creating-your-own-aliases>Creating Your Own Aliases<a hidden class=anchor aria-hidden=true href=#creating-your-own-aliases>#</a></h4><p>Setting aliases is a breeze with the <code>Set-Alias</code> command. For instance, to create a handy shortcut like <code>date</code> for the <code>Get-Date</code> command, simply execute:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=c># Set Alias</span>
</span></span><span class=line><span class=cl><span class=nb>Set-Alias</span> <span class=n>-Name</span> <span class=n>date</span> <span class=n>-Value</span> <span class=nb>Get-Date</span>
</span></span></code></pre></div><p><img loading=lazy src=./assets/image-20240610234907823.png alt=image-20240610234907823></p><h4 id=advanced-alias-techniques-functions-as-aliases>Advanced Alias Techniques: Functions as Aliases<a hidden class=anchor aria-hidden=true href=#advanced-alias-techniques-functions-as-aliases>#</a></h4><p>But what if you crave a date in a different format, with little more customization that is not offered by native command?</p><p>The preferred way is to create a function that wraps into a function, this provides the most customziation options.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=kd>function</span><span class=w> </span><span class=nb>sdate</span> <span class=p>{</span> <span class=p>(</span><span class=nb>Get-Date</span><span class=p>).</span><span class=py>ToShortDateString</span><span class=p>()</span> <span class=p>}</span>
</span></span></code></pre></div><h4 id=tab-completion-the-alias-alternative>Tab Completion: The Alias Alternative<a hidden class=anchor aria-hidden=true href=#tab-completion-the-alias-alternative>#</a></h4><p>While aliases are undoubtedly handy for saving keystrokes, I&rsquo;m a firm believer in the power of tab completion. Luckily, PowerShell has this feature built right in, so there&rsquo;s no need for any extra plugins. The more you use PowerShell, the more tab completion will become an instinctive part of your workflow.</p><p>In the <code>date</code> example, instead of setting an alias, it&rsquo;s far more efficient to simply type <code>Get-D</code> and hit the Tab key. PowerShell will magically complete the command to <code>Get-Date</code> for you!</p><p>This approach not only saves you from memorizing aliases but also empowers you to explore the full range of available commands with ease. It&rsquo;s a win-win!</p><blockquote><p><strong>Note</strong>: Remember, PowerShell is case-insensitive, so typing <code>get-date</code> and <code>Get-Date</code> produces the same result. I tend to avoid CamelCasing in the terminal, but tab completion swoops in to automatically convert the command to the appropriate case, ensuring my code remains clean and readable.</p></blockquote><p>üåç Environment Variables: Data Storage</p><p>Environment variables are like the multi-purpose tools of your PowerShell Session. They can store a variety of information that can be used to customize your environment, control script behavior, and streamline your workflow. Storing confidential and private information in Env Variable isolates your data from the script. Here are some practical use cases:</p><ul><li>API Keys and Tokens</li><li>Configuration Settings</li><li>Paths</li></ul><p>PowerShell allows you to easily set env variable,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nv>$env:TOKEN</span>  <span class=p>=</span> <span class=s2>&#34;xyz-token-value&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>$env:EDITOR</span> <span class=p>=</span> <span class=s2>&#34;nvim&#34;</span>
</span></span></code></pre></div><p>Depending on your operating system, these variables can operate in system, user, or session contexts. Env variable set in <code>PROFILE</code> is confined to session context.</p><h3 id=-supercharging--with-modules>‚ö°Ô∏è Supercharging with Modules<a hidden class=anchor aria-hidden=true href=#-supercharging--with-modules>#</a></h3><p>With the basics in place, it&rsquo;s time to inject some serious functionality into your shell using external Modules. Most PowerShell modules can be downloaded from <a href=https://www.powershellgallery.com/>PSGallery</a> which has more than 13k unique packages.</p><blockquote><p>Note: Not all packages are build equal, take necessary precautions before you download any packages form external source.</p></blockquote><p>Every module you add to your arsenal unlocks a new dimension of PowerShell capabilities. To kickstart your journey, here are some must-have modules that will instantly elevate your shell game:</p><ul><li><strong>PSReadline:</strong> command line editing in the PowerShell console host</li><li><strong>PowerShellGet:</strong> Modern module manager</li><li><strong>oh-my-posh:</strong> Prompt enhancer</li><li><strong>Terminal-Icons:</strong> Show icons for files and folders</li></ul><p>Take PSReadLine, for instance. It&rsquo;s not just a minor upgrade; it completely transforms your console experience with enhanced tab completion and customizable keybindings. Once you&rsquo;ve installed this powerhouse module, a simple configuration tweak unleashes its full potential: a list view prediction mode that blows the standard tab completion out of the water.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=c># Assuming you have PSReadline Module installed</span>
</span></span><span class=line><span class=cl><span class=nb>Set-PSReadLineKeyHandler</span> <span class=n>-Chord</span> <span class=n>F2</span> <span class=n>-Function</span> <span class=n>SwitchPredictionView</span>
</span></span><span class=line><span class=cl><span class=nb>Set-PSReadLineOption</span> <span class=n>-EditMode</span> <span class=n>Vi</span>
</span></span></code></pre></div><p>Screen-grab of <code>psreadline</code> prediction in list view. Source for prediction is <code>history</code> .</p><p><img loading=lazy src=./assets/image-20240611234407167.png alt=image-20240611234407167></p><p>üîç <strong>Completion for External Tools: Bridging the Gap</strong></p><p>A growing number of command-line interface (CLI) tools now offer completion support for PowerShell. This is a major win for productivity, as it eliminates the need to constantly refer to help menus or external documentation. With tab completion, these external tools seamlessly integrate into your PowerShell workflow, feeling almost as intuitive as native commands.</p><p>Take the popular <strong>GitHub CLI</strong>, for instance. It&rsquo;s a fantastic utility for interacting with GitHub repositories, issues, and pull requests right from your terminal. With completion support, you can effortlessly navigate its commands and options, making your Git-related tasks a breeze.</p><p>The GH-CLI comes with a built-in PowerShell completion script that you can access using <code>gh completion --shell powershell</code>. Integrating this script into your current terminal session is a straightforward process that unlocks tab completion for all the switches and parameters of the <code>gh</code> CLI tool.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=c># Add gh completion helper to profile</span>
</span></span><span class=line><span class=cl><span class=n>gh</span> <span class=n>completion</span> <span class=n>-s</span> <span class=n>powershell</span> <span class=p>|</span> <span class=nb>Out-String</span> <span class=p>|</span> <span class=nb>Invoke-Expression</span>
</span></span></code></pre></div><h3 id=-custom-functions-sky-is-the-limit>‚ú® Custom Functions: Sky is the limit<a hidden class=anchor aria-hidden=true href=#-custom-functions-sky-is-the-limit>#</a></h3><p>As you progress on your PowerShell journey, your collection of custom functions will inevitably flourish. Resist the temptation to simply copy and paste functions from other sources.</p><p>For instance I have a simple function called <code>Copy-Content</code>. This small yet handy command has saved me ton of keystrokes and tremendously improved my productivity.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=kd>function</span><span class=w> </span><span class=nb>Copy-Content</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>param</span><span class=p>(</span><span class=nv>$Path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>Get-Content</span> <span class=nv>$Path</span> <span class=p>|</span> <span class=nb>Set-Clipboard</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>While you can certainly draw inspiration from others, let your own unique workflow and needs guide the growth of your function library.</p><h3 id=--background-jobs-supercharging-without-the-startup-lag>üöÄ Background Jobs: Supercharging without the Startup Lag<a hidden class=anchor aria-hidden=true href=#--background-jobs-supercharging-without-the-startup-lag>#</a></h3><p>Here&rsquo;s a productivity trick that might not be in the PowerShell playbook, but it&rsquo;s a game-changer for me.</p><p>There are certain tasks you might want to run periodically or on demand, like updating modules or fetching configuration files from a remote source. The conventional wisdom often points to scheduled tasks, which certainly work but operate outside your shell&rsquo;s cozy environment.</p><p>Since I practically live in the terminal, I prefer to set these tasks as background jobs directly within my PowerShell session. This allows me to manage and monitor them alongside my other PowerShell activities, keeping everything neatly centralized.</p><blockquote><p>‚ö†Ô∏è <strong>Important Note:</strong> Running these tasks as background jobs is essential. If you execute them directly within your profile, your profile&rsquo;s load time will skyrocket, forcing you to wait for the tasks to finish every time you launch a new PowerShell session. Nobody wants that!</p></blockquote><h4 id=benefits-of-running-it-in-profile-and-not-as-scheduled-job>Benefits of running it in profile and not as scheduled job<a hidden class=anchor aria-hidden=true href=#benefits-of-running-it-in-profile-and-not-as-scheduled-job>#</a></h4><ol><li>It sits in <code>$PROFILE</code> as PowerShell code so its easy to modify (and version control)</li><li>You can get status of the job at any point by running <code>Get-Job</code></li><li>On-Demand Execution, Trigger tasks manually by reloading your profile with <code>. $PROFILE</code>.</li><li>Easy to manage and version control</li></ol><p>This is how I update one of the module <a href=https://github.com/JustinGrote/ModuleFast>ModuleFast</a> (an epic module by <a href=https://github.com/JustinGrote>Justin Grote</a>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nv>$sb</span> <span class=p>=</span> <span class=p>{</span> <span class=nb>Update-PSResource</span> <span class=n>-Name</span> <span class=n>ModuleFast</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nb>Start-Job</span> <span class=n>-ScriptBlock</span> <span class=nv>$sb</span> <span class=n>-Name</span> <span class=n>ProfileJob</span>
</span></span></code></pre></div><p>This approach opens up a world of automation possibilities. You can delegate virtually any time-consuming task to your profile&rsquo;s background jobs. I personally have an army of jobs working tirelessly behind the scenes, handling tasks like cleaning temp directory, Fetching Git Projects, Upgrading Modules and more.</p><h2 id=-wrapping-up>üéÅ Wrapping Up<a hidden class=anchor aria-hidden=true href=#-wrapping-up>#</a></h2><p>I have briefly explained each profile component and its role in improving Profile</p><p>This is just the beginning! In Part 2, we&rsquo;ll tackle profile management, organization, conditional loading and advanced techniques. Get ready to elevate your PowerShell game to the next level and make your shell truly your own.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.belibug.com/tags/powershell/>Powershell</a></li><li><a href=https://blog.belibug.com/tags/guide/>Guide</a></li><li><a href=https://blog.belibug.com/tags/tools/>Tools</a></li><li><a href=https://blog.belibug.com/tags/pwsh/>Pwsh</a></li><li><a href=https://blog.belibug.com/tags/code/>Code</a></li></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>