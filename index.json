[{"content":"The PowerShell profile is the unsung hero of your shell, a secret weapon that can transform your mundane tasks into an efficiency and fun excercise.\nIf your PowerShell usage is confined to executing one-liners or running scripts from shared folders within the outdated ISE, you\u0026rsquo;re missing out on a world of customization and efficiency.\nThis is the first part of a two-part series where we\u0026rsquo;ll dive deep into the world of profile customization. Get ready to discover a treasure trove of tips and tricks that\u0026rsquo;ll elevate your PowerShell experience to legendary status. ‚ú®\nüîß Essential Setup This guide is optimized for PowerShell 7. If you\u0026rsquo;re still clinging to an older version, I highly recommend upgrading to the latest and greatest for the optimal experience.\nOptional Pro Tip: For Windows users, consider installing the Windows Terminal or any other modern terminal that boasts rich ANSI support. This will enhance the visual appeal and functionality of your PowerShell environment. Mac and Linux users typically have this capability built into their terminals already (mostly).\nüìù Crafting Your PowerShell Profile If you\u0026rsquo;re a PowerShell profile newbie, no worries! We\u0026rsquo;ll start from scratch. Just fire up your terminal and execute the following code:\nif (!(Test-Path -Path $PROFILE)) { New-Item -ItemType File -Path $PROFILE -Force } # Open in Default editor, choose notepad if you are prompted to select one Invoke-Item $PROFILE This nifty snippet will create your profile file if it doesn\u0026rsquo;t already exist and open it in your default text editor. Easy peasy!\nüß© Building Blocks of Your Profile To keep your profile tidy, maintainable, and efficient, I\u0026rsquo;ve categorized the components into distinct groups. While you don\u0026rsquo;t have to incorporate every single element, understanding the possibilities and loading mechanisms is key to unleashing the full potential of your PowerShell profile.\nLet\u0026rsquo;s explore each component in detail. In the next article (Part 2 of 2), I\u0026rsquo;ll guide you through assembling these building blocks to create a powerhouse profile that\u0026rsquo;s tailored to your unique needs.\nüé® Prompt Makeover: Let Your Personality Shine Through One of the most obvious signs that someone has leveled up their PowerShell game is a personalized prompt. The default prompt might suffice for a quick virtual machine session, but why settle for mediocrity when you can have a prompt that\u0026rsquo;s as unique as you are?\nBelow is the basic Default prompt, its not too bad, but we can easily enhance it.\nLet\u0026rsquo;s inject some life into your terminal with this simple yet eye-catching prompt function,\nfunction prompt { $curPath = (Get-Location).Path $curTime = Get-Date -Format \u0026#39;HH:mm:ss\u0026#39; Write-Host $curPath -ForegroundColor Red -NoNewline Write-Host \u0026#39; :: \u0026#39; -NoNewline Write-Host $curTime -ForegroundColor Blue -NoNewline Write-Host \u0026#39; ‚ö°\u0026#39; -NoNewline return \u0026#39; \u0026#39; } This function replaces the bland default prompt with a stylish colorful prompt with path, time and classic thunder emoji. Feel free to customize and experiment with different prompt and make it truly yours.\nPrompt Pro Tip: This is just a taste of the incredible prompt customization possibilities at your fingertips! Dive into Microsoft\u0026rsquo;s about_Prompts documentation to uncover a wealth of additional options.\nIf you\u0026rsquo;re looking for ready-made prompt awesomeness, consider exploring popular modules like Oh My Posh or binaries like Starship. These tools offer a vast array of pre-designed prompts that can instantly elevate your PowerShell style.\nBeyond the prompt, you can personalize your PowerShell experience even further by customizing fonts, font sizes, backgrounds, themes, and other visual elements. These settings vary depending on your terminal app and are typically accessible through its configuration or settings page.\nüîÄ Alias Wizardry: PowerShell Shortcuts Aliases are the bread and butter of any shell configuration, and PowerShell is no exception. While PowerShell handles aliases in its own unique way (either within functions/scripts or as manual creations), the concept remains the same, create shortcuts to frequently used commands for a smoother workflow.\nDiscovering Existing Aliases Before diving into custom aliases, familiarize yourself with the built-in aliases that PowerShell provides. Many common Linux-style commands already have aliases defined, so you might discover that the shortcut you need is already at your disposal.\n# Get all alias in the current session] Get-Alias Creating Your Own Aliases Setting aliases is a breeze with the Set-Alias command. For instance, to create a handy shortcut like date for the Get-Date command, simply execute:\n# Set Alias Set-Alias -Name date -Value Get-Date Advanced Alias Techniques: Functions as Aliases But what if you crave a date in a different format, with little more customization that is not offered by native command?\nThe preferred way is to create a function that wraps into a function, this provides the most customziation options.\nfunction sdate { (Get-Date).ToShortDateString() } Tab Completion: The Alias Alternative While aliases are undoubtedly handy for saving keystrokes, I\u0026rsquo;m a firm believer in the power of tab completion. Luckily, PowerShell has this feature built right in, so there\u0026rsquo;s no need for any extra plugins. The more you use PowerShell, the more tab completion will become an instinctive part of your workflow.\nIn the date example, instead of setting an alias, it\u0026rsquo;s far more efficient to simply type Get-D and hit the Tab key. PowerShell will magically complete the command to Get-Date for you!\nThis approach not only saves you from memorizing aliases but also empowers you to explore the full range of available commands with ease. It\u0026rsquo;s a win-win!\nNote: Remember, PowerShell is case-insensitive, so typing get-date and Get-Date produces the same result. I tend to avoid CamelCasing in the terminal, but tab completion swoops in to automatically convert the command to the appropriate case, ensuring my code remains clean and readable.\nüåç Environment Variables: Data Storage\nEnvironment variables are like the multi-purpose tools of your PowerShell Session. They can store a variety of information that can be used to customize your environment, control script behavior, and streamline your workflow. Storing confidential and private information in Env Variable isolates your data from the script. Here are some practical use cases:\nAPI Keys and Tokens Configuration Settings Paths PowerShell allows you to easily set env variable,\n$env:TOKEN = \u0026#34;xyz-token-value\u0026#34; $env:EDITOR = \u0026#34;nvim\u0026#34; Depending on your operating system, these variables can operate in system, user, or session contexts. Env variable set in PROFILE is confined to session context.\n‚ö°Ô∏è Supercharging with Modules With the basics in place, it\u0026rsquo;s time to inject some serious functionality into your shell using external Modules. Most PowerShell modules can be downloaded from PSGallery which has more than 13k unique packages.\nNote: Not all packages are build equal, take necessary precautions before you download any packages form external source.\nEvery module you add to your arsenal unlocks a new dimension of PowerShell capabilities. To kickstart your journey, here are some must-have modules that will instantly elevate your shell game:\nPSReadline: command line editing in the PowerShell console host PowerShellGet: Modern module manager oh-my-posh: Prompt enhancer Terminal-Icons: Show icons for files and folders Take PSReadLine, for instance. It\u0026rsquo;s not just a minor upgrade; it completely transforms your console experience with enhanced tab completion and customizable keybindings. Once you\u0026rsquo;ve installed this powerhouse module, a simple configuration tweak unleashes its full potential: a list view prediction mode that blows the standard tab completion out of the water.\n# Assuming you have PSReadline Module installed Set-PSReadLineKeyHandler -Chord F2 -Function SwitchPredictionView Set-PSReadLineOption -EditMode Vi Screen-grab of psreadline prediction in list view. Source for prediction is history .\nüîç Completion for External Tools: Bridging the Gap\nA growing number of command-line interface (CLI) tools now offer completion support for PowerShell. This is a major win for productivity, as it eliminates the need to constantly refer to help menus or external documentation. With tab completion, these external tools seamlessly integrate into your PowerShell workflow, feeling almost as intuitive as native commands.\nTake the popular GitHub CLI, for instance. It\u0026rsquo;s a fantastic utility for interacting with GitHub repositories, issues, and pull requests right from your terminal. With completion support, you can effortlessly navigate its commands and options, making your Git-related tasks a breeze.\nThe GH-CLI comes with a built-in PowerShell completion script that you can access using gh completion --shell powershell. Integrating this script into your current terminal session is a straightforward process that unlocks tab completion for all the switches and parameters of the gh CLI tool.\n# Add gh completion helper to profile gh completion -s powershell | Out-String | Invoke-Expression ‚ú® Custom Functions: Sky is the limit As you progress on your PowerShell journey, your collection of custom functions will inevitably flourish. Resist the temptation to simply copy and paste functions from other sources.\nFor instance I have a simple function called Copy-Content. This small yet handy command has saved me ton of keystrokes and tremendously improved my productivity.\nfunction Copy-Content { param($Path) Get-Content $Path | Set-Clipboard } While you can certainly draw inspiration from others, let your own unique workflow and needs guide the growth of your function library.\nüöÄ Background Jobs: Supercharging without the Startup Lag Here\u0026rsquo;s a productivity trick that might not be in the PowerShell playbook, but it\u0026rsquo;s a game-changer for me.\nThere are certain tasks you might want to run periodically or on demand, like updating modules or fetching configuration files from a remote source. The conventional wisdom often points to scheduled tasks, which certainly work but operate outside your shell\u0026rsquo;s cozy environment.\nSince I practically live in the terminal, I prefer to set these tasks as background jobs directly within my PowerShell session. This allows me to manage and monitor them alongside my other PowerShell activities, keeping everything neatly centralized.\n‚ö†Ô∏è Important Note: Running these tasks as background jobs is essential. If you execute them directly within your profile, your profile\u0026rsquo;s load time will skyrocket, forcing you to wait for the tasks to finish every time you launch a new PowerShell session. Nobody wants that!\nBenefits of running it in profile and not as scheduled job It sits in $PROFILE as PowerShell code so its easy to modify (and version control) You can get status of the job at any point by running Get-Job On-Demand Execution, Trigger tasks manually by reloading your profile with . $PROFILE. Easy to manage and version control This is how I update one of the module ModuleFast (an epic module by Justin Grote)\n$sb = { Update-PSResource -Name ModuleFast } Start-Job -ScriptBlock $sb -Name ProfileJob This approach opens up a world of automation possibilities. You can delegate virtually any time-consuming task to your profile\u0026rsquo;s background jobs. I personally have an army of jobs working tirelessly behind the scenes, handling tasks like cleaning temp directory, Fetching Git Projects, Upgrading Modules and more.\nüéÅ Wrapping Up I have briefly explained each profile component and its role in improving Profile\nThis is just the beginning! In Part 2, we\u0026rsquo;ll tackle profile management, organization, conditional loading and advanced techniques. Get ready to elevate your PowerShell game to the next level and make your shell truly your own.\n","permalink":"https://blog.belibug.com/post/ps-profile-01/","summary":"Simplify Your Workflow, Detailed guide to setting up a Flexible PowerShell Profile","title":"Building a Modular PowerShell Profile - Part 1 of 2"},{"content":"Introducing Mold - The Missing PowerShell Templating Engine Mold is PowerShell template \u0026amp; scaffolding engine that lets you effortlessly craft templates for any language (not limited to PowerShell), on any platform. üöÄ Deploy in a flash with interactive prompts or answer files ‚Äì your choice!\nReady to see Mold work in action? Here\u0026rsquo;s a sneak peek of what deploying a template looks like:\nüå± What\u0026rsquo;s Templating \u0026amp; Why Should You Care? Think of templates as blueprints for your code. They\u0026rsquo;re pre-formatted files with placeholders for variables, like names, dates, blocks of code. When you use a template, you simply fill in the blanks, and voil√† ‚Äì you\u0026rsquo;ve got a customized script or project ready to go!\nWhy is this awesome?\nSave Time: No more writing the same boilerplate code over and over. Consistency: Templates help ensure your projects follow best practices and maintain a uniform style. Scalability: Easily create multiple projects or files from a single template. Flexibility: Customize your templates to fit your specific needs. Some Practical Use Cases\nNew modules with consistent boilerplate code. Quickly generate complex configuration files from pre-defined templates. Build project scaffolding with a few simple commands. Standardize documentation across your PowerShell projects. Easy template for Minutes of meeting and personal notes. Mold is a template engine, a powerful tool that acts as a processor for your templates and data. This Wikipedia article explains the concept of templating in depth.\nIn short, templating is a superpower for developers, boosting productivity and reducing errors. And with Mold, harnessing that power is easier than ever before!\nüöÄ Can\u0026rsquo;t Wait to Get Started? If you\u0026rsquo;re itching to give Mold a whirl, you can grab the module from the PowerShell Gallery and explore the source code on GitHub right now!\nBut wait, there\u0026rsquo;s more! If you\u0026rsquo;re ready to dive deeper, stick around and join me as I walk you through the step-by-step process of building a Mold template from the ground up. We\u0026rsquo;ll cover all the key features and even deploy the template to see it in action. Let\u0026rsquo;s get started!\nThe Why? Mold began as my own little side project to scratch a personal templating itch. But, it quickly blossomed into something bigger ‚Äì a solution to a longstanding gap in the PowerShell ecosystem. Now, I know what you\u0026rsquo;re thinking: \u0026ldquo;We\u0026rsquo;ve got Plaster, right?\u0026rdquo; And yes, while Plaster has served the community well, I believe there\u0026rsquo;s room for a fresh approach. Let\u0026rsquo;s dive into why I think a new templating engine is not only welcome but necessary. üòâ\nWhile Plaster\u0026rsquo;s deep ties to PowerShell offer undeniable advantages, they also come with certain constraints. I aimed to create something more versatile ‚Äì a tool that treats text as its playground, regardless of language.\nLet\u0026rsquo;s face it, Plaster\u0026rsquo;s PowerShell 7 support is\u0026hellip; well, underwhelming. üòû It\u0026rsquo;s been gathering dust for years and demands those long, convoluted XML files that nobody enjoys writing.\nThe How? ü§î Still Here? Alright, I see you\u0026rsquo;re intrigued. Perhaps you\u0026rsquo;re even starting to agree that a fresh templating engine is not that bad idea after all. Let\u0026rsquo;s unveil what Mold brings to the table, shall we?\nYou can find a deep dive into Mold\u0026rsquo;s concepts, installation, usage, and even some pro tips on our GitHub repository. I encourage you to even scour through the actual code to get a feel for how Mold works under the hood.\nThis blog post will focus on a hands-on walkthrough of crafting and deploying your very own Mold templates. So, buckle up and get ready to mold some code!\nExample Project - PowerShell Script Template for new Scripts I spin up new PowerShell scripts all the time, whether just for quickly experimenting and testing things out, or for projects that I know will be around for a while. There‚Äôs a few basic things that I like all my scripts to have. - Daniel Schroeder\nLets tackle this challenge. I wanted a bare-bones script template that delivers the essentials:\nscript.ps1: A file with a name that perfectly matches its purpose, along with a basic script structure. Docs : A dedicated folder to hold extra files related to script. README.md: A markdown file within the Docs folder for documenting the script\u0026rsquo;s purpose/instruction. NOTE: This example is intentionally simple (although less practical), designed to illustrate Mold\u0026rsquo;s core concepts and functionality. In real-world scenarios, your templates can be far more complex and tailored to your specific needs.\nLet your imagination run wild! üåà Think about the repetitive tasks in your PowerShell projects. Could you automate them with a template? The possibilities are endless!\nStep 1: Prep the Template Directory First things first, let\u0026rsquo;s get Mold up and running on your system. It\u0026rsquo;s a quick and easy installation from the PowerShell Gallery:\nInstall-Module -Name Mold Now, let\u0026rsquo;s set the stage for our PowerShell script template. We\u0026rsquo;ll call our directory PowerScript, all the code in their is boilerplate code that I added manually on my own.\nPowerScript ‚îú‚îÄ‚îÄ Docs ‚îÇ ‚îî‚îÄ‚îÄ README.md ‚îî‚îÄ‚îÄ script.ps1 Here\u0026rsquo;s the content of script.ps1:\nthe Readme.md file and its content\nStep 2 : Add Placeholders Time to make our template dynamic! Let\u0026rsquo;s update script.ps1 and README.md with Mold\u0026rsquo;s placeholder magic\nAnd this README.md as below\nStep 3 : Generate MoldManifest and Update fields Now that we\u0026rsquo;ve added placeholders, let\u0026rsquo;s create the MoldManifest.json file, Just run the following command, either from within your PowerScript directory or by specifying its full path:\n# Generate Mold Manifest New-MoldManifest -Path ./PowerScript After running the command, you\u0026rsquo;ll find the following MoldManifest.json file in your PowerScript directory:\nThis file is the backbone of your template. It defines the questions Mold will ask when the template is invoked. You can customize this file further to tailor your template to your exact needs.\nRemember, you can personalize the \u0026ldquo;Message,\u0026rdquo; \u0026ldquo;Prompt,\u0026rdquo; \u0026ldquo;Caption,\u0026rdquo; and \u0026ldquo;Choices/Description\u0026rdquo; fields to provide even clearer context for your questions. Make this template truly yours!\nStep 3.5 : Supercharge Your Template with MOLD_SCRIPT (Optional, but Oh So Powerful) What if you want your template to do more than just swap out text? Maybe you need to rename files, tweak content based on user input, or perform some other scripting wizardry. That\u0026rsquo;s where MOLD_SCRIPT.ps1 steps in! This special file is Mold\u0026rsquo;s secret weapon for executing custom logic at the end of the template deployment process.\nIn our example, we\u0026rsquo;ll use MOLD_SCRIPT.ps1 to rename the generic script.ps1 file to something more meaningful, based on the input we gather from the user.\nAll user-provided data is consolidated within the $MoldData variable, accessible for use within your custom logic. To maintain system integrity, scripts operate in an isolated environment, able to modify only template content and not the file/content already present in final output directory.\nStep 4 : Ready to roll You\u0026rsquo;ve just built a reusable template that can effortlessly crank out new PowerShell scripts. Now, let\u0026rsquo;s explore the different ways you can put this template to work.\nManually point to path ‚Äã\tIf you just need one-off template run or running someone else‚Äôs template, you can always manually point to the template directory. This method gives you full control over where Mold looks for your template. Just remember, you\u0026rsquo;ll need to specify the full path each time.\n# Full path to template directory Invoke-Mold -TemplatePath \u0026#34;/Some/Path/to/Template/PowerScript\u0026#34; # If you donot provide destination path, template will be deployed to current working directory Add to MOLDTEMPLATES environment path\nMy favorite way to store templates is in the MOLDTEMPLATES environment variable. It\u0026rsquo;s like a VIP lounge for your templates, offering perks like:\nTab Completion: Never fumble for file paths again, you can invoke templates by name Multiple Paths: Add as many template directories as you want, just separate them with semicolons. # invoke by name Invoke-Mold -Name PowerScript This trick is especially handy if you\u0026rsquo;re into Git version control for your templates. It\u0026rsquo;s the perfect way to keep your templates organized, easily accessible and isolated from PowerShell modules/code.\nThe Moment of Truth: Invoking Your Template You\u0026rsquo;re all set! Now, let\u0026rsquo;s see the fruits of your labor. Here\u0026rsquo;s what happens when you run the Invoke-Mold command:\nAs you can see, Mold seamlessly guides you through the template\u0026rsquo;s questions, gathers your input, and then generates a fully customized script along with its accompanying documentation. Effortless and efficient! ‚ú®\nAnswer File Not a fan of answering prompts? Or perhaps you\u0026rsquo;re looking to automate template creation within your scripts. No problem! Mold\u0026rsquo;s got you covered with answer files.\nYou can easily generate a template for your answer file using the New-MoldAnswerFile command, providing either the template path or its name.\nHere\u0026rsquo;s a simple example of an answer file for our script template, the only required elements here is Key and Answer all other fields are there to provide you better context.\nWith this file in hand, you can feed it to the Invoke-Mold command and watch it execute without any manual intervention. It\u0026rsquo;s the perfect way to streamline your templating workflow and achieve hands-off automation!\n# invoke with AnswerFile Invoke-Mold -TemplatePath .\\PowerScript -AnswerFile .\\Mold_Answer_File.json And the Results Are In! Here\u0026rsquo;s a sneak peek at the final output after running the command:\nAs you can see, Mold not only replaced placeholders with your answers but also worked its magic behind the scenes. It renamed script.ps1 to SystemUptime.ps1, injected a helpful script header, and even updated the filename within the help content. Now that\u0026rsquo;s what I call a smart template!\nEven Markdown file was updated in Docs folder\nüì¢ Mold Community Call-Out! Mold is an open-source project, and I\u0026rsquo;m always eager for your input! Whether you have a cool template idea, a feature request, or you\u0026rsquo;ve encountered a bug, I\u0026rsquo;d love to hear from you.\nSwing by the Mold GitHub repository and let\u0026rsquo;s make Mold even more awesome together! Submit your ideas, report issues, or even contribute code. Let\u0026rsquo;s build a vibrant community of Mold enthusiasts! üí™\nüôå Conclusion With Mold, you\u0026rsquo;re not just creating templates; you\u0026rsquo;re crafting a toolbox of productivity boosters. üöÄ\nIf you encounter any issues or have suggestions, don\u0026rsquo;t hesitate to open an issue. Your voice matters, Let\u0026rsquo;s shape the future of PowerShell templating!\nThank you so much, happy scripting!\n","permalink":"https://blog.belibug.com/post/ps-mold/","summary":"The Missing Piece in Your PowerShell Toolkit, the Intuitive Template Engine üõ†Ô∏è","title":"Introducing PowerShell Templating Engine - Mold"},{"content":"Transitioning from writing individual scripts to creating a PowerShell module is a small step with significant rewards. Once you\u0026rsquo;ve crafted your own module, the possibilities are endless. However, why stop there when you can share your module with the world through a public repository like PSGallery? Publishing your modules to public registries offers numerous advantages.\nI published my own Module last week, check it out for reference SecretBackup - PSgallery\nWhy publish You might think your module is too niche, not well-organized, or come up with countless reasons to avoid going public. However, there are several benefits to publishing your module:\nEncourages you to remove private or personally identifiable code from your module.\nPrompts you to generalize the module so it works on any machine.\nProvides an opportunity to learn about APIs and the PSGallery contribution process.\nEnhances your skills with Git and platforms like GitHub or GitLab when creating a public repository to share your code.\nHelps you adhere to best practices in coding and module development.\nEnhances communication skills by learning to express your ideas clearly.\nEstablishes a public profile for yourself and fosters contributions to the community\nSample Module on PowerShell Gallery. Everything from source, tests and build scripts are in the repo. Shows how simple and automated publishing module to PSGallery can be!\nHow to get started There are several guides available on how to write and publish modules to PSGallery, with one of the best being the Microsoft Docs guide. This article aims to provide you with the essential basics to help you get started.\nPrepare Module First you have to get the module ready and meet PSGallery standards. One can get by a simple local module with just .psm1 file. This will not be sufficient for PSGallery. Below are minim requirement for PSGallery module.\nManifest File Your module must include a manifest file (.psd1). This file contains the metadata for your module and requires several fields to be updated to meet PSGallery requirements. All the information displayed on PSGallery is retrieved from the content of the .psd1 file. Key fields to update include:\nModule Name Version (using Semantic Versioning) Tags (for visibility and searchability) Project URI (optional but recommended) You can create a template manifest file using the New-ModuleManifest cmdlet. This template serves as a reference for all the fields you can update. It\u0026rsquo;s best to populate as much information as possible to ensure your module is well-documented and easily discoverable.\nWrite Help Local modules often don\u0026rsquo;t receive much attention when it comes to documentation, as they are typically used by you or a small team nearby. However, a complete stranger on the other side of the world won\u0026rsquo;t have any idea how to run or use the commands in your module. Therefore, it\u0026rsquo;s crucial to write detailed help for each function, complete with examples. There are two key places where you can provide this explanation for your module:\nComment-Based Help: Used to provide detailed help for individual commands within the module. Repository README Page: Contains descriptions of the module, its approach, design decisions, and roadmap. Module Structure This is optional initially, but quickly becomes crucial, especially when others want to contribute. If your entire module is contained within a single psm1 file, understanding and contributing to it becomes nearly impossible. There are several methods and best practices for structuring a module, such as this one by Kevin Marauette, that help create readable and easy-to-collaborate modules.\nI have a Module built just to make building module simple and efficient. Check out ModuleTools. You can download the ModuleTools from [PSGallery](https://www.powershellgallery.com/packages/ModuleTools.\nInstall-Module -Name ModuleTools Code Quality and Testing Parameter naming conventions, function naming conventions, and even the content in your help files become crucial when sharing code with others. Writing code that is easy for others to read also makes it easier for you to revisit and understand years later.\nTesting is initially optional but becomes crucial when ensuring your module doesn\u0026rsquo;t break on other machines. Pester tests simplify running tests (easy to run as CI) and help ensure that adding or modifying code doesn\u0026rsquo;t affect existing functions.\nPester syntax might seem daunting to get started, but once you get the basics it becomes as simple as any PowerShell script.\nPublish Locally Set up a local file share-based Private NuGet repository on your machine and practice publishing to it. This will help you become proficient before you\u0026rsquo;re ready to publish to PSGallery.\nConclusion In conclusion, publishing your PowerShell module to PSGallery opens up a world of opportunities. By following best practices in module development, writing clear documentation, and incorporating testing, you not only enhance your module\u0026rsquo;s usability but also contribute positively to the community. Embrace the journey from writing scripts to creating modules‚Äîit\u0026rsquo;s a rewarding experience that strengthens your coding skills and fosters collaboration with others worldwide. Start sharing your creations today and see how your contributions can make a difference. Happy coding!\n","permalink":"https://blog.belibug.com/post/ps-psgallery/","summary":"From Script to Shared Success, Publishing on the PowerShell Gallery","title":"Publishing Module to PSGallery"},{"content":"There is no shortage of modules in the PowerShell Gallery for building modules. In fact, there are at least a dozen actively managed modules capable of building complex modules. So, you might ask, why choose ModuleTools and what makes it special? Allow me to explain.\nBuilding modules doesn\u0026rsquo;t have to be complex or an all-or-nothing process. While I have drawn a lot of inspiration from InvokeBuild and the Sampler module builder, they are overly complex and have a steep learning curve. They introduce their own assert, exec, and requires syntax that you need to learn. They depend on several other Modules (like psake, plaster).\nIntroducing ModuleTools ModuleTools employs a straightforward structure and a single data file (project.json) to manage the entire module development process. It allows you to build, run Pester tests, or perform semantic version upgrades with ease. You can customize its usage by selecting only the tasks you need, such as invoking builds while skipping tests. Additionally, the same commands work seamlessly for both local and pipeline builds.\nIt is entirely self-contained, eliminating the need for scaffolding tools (like Plaster), build tools (like Psake), or the maintenance of non-functional helper files (like psd1 and build.ps1).\nFind the source code for SecretBackup module on GitHub which will be used for reference in below examples.\nWhy Build at all? If you have built module yourself or know what you are doing, skip directly to next section\nUnlike other compiled languages, there is no formal concept of a \u0026ldquo;build\u0026rdquo; in PowerShell development. However, creating a well-organized and easy-to-manage PowerShell module requires a certain structure and organization. Build tools help achieve this by generating the necessary structure with ease.\nThe organizational structure is the most compelling reason to have a build mechanism. Instead of cramming hundreds of lines of code into a single psm1 file, it\u0026rsquo;s more efficient to give each function its own file.\nThe idea is that each file contains one function, and each function performs a single task. This approach makes files and functions easier to manage and control through versioning.\nGetting Started with ModuleTools New-MTModule is all you need to set up your project. In fewer than six interactive steps, you\u0026rsquo;ll be ready to start writing beautiful modules. Below is a screenshot of setting up a test module project.\nProject JSON file This file contains key information about the project, including everything from the module\u0026rsquo;s GUID to the Pester configuration. It is created automatically with New-MTModule, or you can copy a sample file from here.\n{ \u0026#34;ProjectName\u0026#34;: \u0026#34;ModuleName\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Description of Module\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;Manifest\u0026#34;: { \u0026#34;Author\u0026#34;: \u0026#34;Manjunath Beli\u0026#34;, \u0026#34;PowerShellHostVersion\u0026#34;: \u0026#34;7.4\u0026#34;, \u0026#34;GUID\u0026#34;: \u0026#34;Use New-Guid to generate guid\u0026#34;, \u0026#34;Tags\u0026#34;: [], \u0026#34;ProjecUri\u0026#34;: \u0026#34;\u0026#34; } } Folder Structure If you used the New-MTModule command the folder structure is already setup for you. If you like doing it manually, these are important folders\nEach folder serves a purpose\nFolder Purpose Root\\project.json This is main project info file in json format Src\\private Functions required for module but not exposed to user Src\\public Functions that are exposed in module Src\\resources Any file you want to ship with module (like config.ini image.jpg) tests all the pester tests dist auto generated, the output of ModuleTools invoke build command For instance, this is folder structure in one of my module SecretBackup\nPowerShell Functions I like to break my functions into simple, one-task-only scripts. The name of the function doesn\u0026rsquo;t matter, but each file should contain only one top level function. Everything in the public folder gets exported as module commands, while everything in the private folder is accessible within the module but not exposed to the user.\nSample Function\n# File SayHello.ps1 function Write-Greetings { Write-Host \u0026#34;Hello Stranger!\u0026#34; } Name of the file is not important, ensure the content of file has one top level function only.\nBuild Building a module is as simple as Invoke-MTBuild. Use -Verbose if you want to see more details during build. It takes less than a second to build.\nTests You can also easily run Tests using Invoke-MTTest. Ensure all your tests are in tests folder in root directory of project.\nAll the pester configuration can be stored in project.json which makes running pester test easy and consistent.\nOutput Output files are kept in the dist folder located in the project\u0026rsquo;s root directory. Each time you run a build, this directory is cleaned up, and the module is built from scratch.\nAutomation All configuration details are stored in project.json, which is easy to parse and use in automation. The module also includes the Get-MTProjectInfo command, which provides additional properties of the module, allowing you to easily incorporate them into Pester tests and automation.\nAll commands are terminating on error, which means you can run them sequentially for easy automation.\n# File run.ps1 ## Build Module Invoke-MTBuild ## Perform Tests Invoke-MTTest ## Publish Module Publish-PSResource -Repository PrivateOwn -path ./dist/SecretBackup This simple flow ensures that the module is published (step-3) only if the Build (step-1) and Tests (step-2) run without errors.\nGithub Actions Module builds can be easily automated using GitHub Actions since all the necessary build commands are contained within the single ModuleTools module. Simply install the module, import it, run the build, and you\u0026rsquo;re good to go.\nSample github action flow, using no 3rd party actions, on a ubuntu host.\nname: Publish to Packages # Controls when the workflow will run on: workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Install ModuleTools module form PSGallery run: Install-PSResource -Repository PSGallery -Name ModuleTools -TrustRepository shell: pwsh - name: Build Module run: Invoke-MTBuild -Verbose shell: pwsh - name: Run Pester Tests run: Invoke-MTTest shell: pwsh - name: Publish Package to Github run: Publish-PSResource -Path ./dist/ModuleTools -Repository PSGallery -ApiKey $Env:ApiKey env: ApiKey: ${{ secrets.PSGALLERY_API }} shell: pwsh Conclusion In conclusion, ModuleTools simplifies PowerShell module development by offering a straightforward approach to organizing functions into single-task scripts, managed through a unified project.json configuration.\nWith ModuleTools, you can easily transform your scattered or lengthy scripts into the well-structured modules you\u0026rsquo;ve always aimed for.\nGot ideas or feedback? Drop them in github issues/discussion! Let\u0026rsquo;s make building PowerShell modules easier and more awesome together.\n","permalink":"https://blog.belibug.com/post/ps-modulebuild/","summary":"From Scattered Scripts to Organized Modules,  Master the craft of creating efficient and reusable code","title":"Simplify PowerShell Module Development with ModuleTools"},{"content":" In the ever-evolving digital landscape, crafting clear and concise content is more crucial than ever. But have you ever felt bogged down by clunky formatting tools or frustrated with endless copy-pasting between writing platforms?\nEnter Markdown, a revolutionary yet straightforward markup language that empowers you to write beautifully formatted text without the hassle.\nWhat\u0026rsquo;s Markdown Markdown is a lightweight markup language that you can use to add formatting elements to plaintext text documents. Created by John Gruber in 2004, Markdown is now one of the world\u0026rsquo;s most popular markup languages.\nWhy Markdown is Magical? Markdown\u0026rsquo;s magic lies in its simplicity. It uses plain text characters and symbols to define formatting elements like headings, bold text, italics, and lists. This eliminates the need for complex menus or endless buttons, allowing you to focus on your content.\nThere are endless guides all over internet on how to write using markdown syntax (reference links at end of article). Here are the basics you need to know in three crisp precise points\nSyntax Description # For heading - For bullet points ![ImageName](Image.jpg) for Image Is it really that simple? Of course not, I had to over simplify it to make a point but this should be sufficient to get 70% of job done.\nModern text processors like OneNote and MS Word offer a vast array of formatting options, letting you create visually stunning documents with a click of a button. They\u0026rsquo;ve become incredibly powerful, thanks to advancements in hardware and processing power. But that power comes at a cost - complexity.\nMarkdown on other hand is simple plain text.\nThis entire blog article is written in markdown\nWhy have I not heard about Markdown before? Markdown has taken the digital world by storm, praised for its simplicity and efficiency. But despite its undeniable strengths, it hasn\u0026rsquo;t quite achieved universal popularity. Particularly for non-technical users, Markdown can present a bit of a hurdle. Here is why:\nLearning curve: symbols and codes are complicated compared to menus and buttons GUI Tools: Unlike WYSIWYG (What You See Is What You Get) editors like MS Word, Markdown offers no live preview of formatting (generally) Limited Design Options: Markdown excels at basic formatting, but complex layouts or design elements are beyond its scope (by design) Niche appeal: while its powerful for developers and IT engineers, Markdown core functionality does not resonate with everyone (yet!) How to bridge that gap? Did you know? Popular chat apps like Teams, Zoom, Slack and WhatsApp allow you to use Markdown for basic formatting within your messages.\nThis is how one can overcome most of the above listed challenges,\nLearning Curve and GUI Tools: Several tool overs menu/buttons and gui interface to build markdown text. This significantly helps understand markdown syntax and ease transition. Limited Design Options: There are several extended Markdown Syntax to address some of design challenges and introduce new design elements like callouts and foldable content. Only for Developers: This is no longer valid as more and more applications are incorporating markdown syntax and formatting in their tools. So how do one get started? Start Small: You don\u0026rsquo;t need advanced editors and software to get started. Begin with an online Markdown editor to familiarize yourself with the basics. There are numerous such editors available; my personal favorite is Dillinger Choose an Editor: There are several WYSIWYG editors you can install on your device that make it easy to learn Markdown syntax. The syntax is so simple that you will quickly become accustomed to using Markdown, even in Notepad. My personal favorite is Obsidian. Keep Practicing: I use Markdown for everything, including personal notes, meeting minutes, project notes, to-do lists, and journaling. It\u0026rsquo;s a lightweight, versatile format that\u0026rsquo;s easy to move across different platforms. The best part is that I\u0026rsquo;m not tied to any specific software or concerned about potential subscription fees for accessing my data. Keep following this blog for more markdown related tips and tricks. See you in next one!\n","permalink":"https://blog.belibug.com/post/markdown-magic/","summary":"The Essential Writing Tool for the Digital Age, Simplify Your Writing Workflow!","title":"The Power of Markdown for Everyone"}]