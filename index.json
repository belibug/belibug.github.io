[{"content":"Transitioning from writing individual scripts to creating a PowerShell module is a small step with significant rewards. Once you\u0026rsquo;ve crafted your own module, the possibilities are endless. However, why stop there when you can share your module with the world through a public repository like PSGallery? Publishing your modules to public registries offers numerous advantages.\nI published my own Module last week, check it out for reference SecretBackup - PSgallery\nWhy publish You might think your module is too niche, not well-organized, or come up with countless reasons to avoid going public. However, there are several benefits to publishing your module:\nEncourages you to remove private or personally identifiable code from your module.\nPrompts you to generalize the module so it works on any machine.\nProvides an opportunity to learn about APIs and the PSGallery contribution process.\nEnhances your skills with Git and platforms like GitHub or GitLab when creating a public repository to share your code.\nHelps you adhere to best practices in coding and module development.\nEnhances communication skills by learning to express your ideas clearly.\nEstablishes a public profile for yourself and fosters contributions to the community\nSample Module on PowerShell Gallery. Everything from source, tests and build scripts are in the repo. Shows how simple and automated publishing module to PSGallery can be!\nHow to get started There are several guides available on how to write and publish modules to PSGallery, with one of the best being the Microsoft Docs guide. This article aims to provide you with the essential basics to help you get started.\nPrepare Module First you have to get the module ready and meet PSGallery standards. One can get by a simple local module with just .psm1 file. This will not be sufficient for PSGallery. Below are minim requirement for PSGallery module.\nManifest File Your module must include a manifest file (.psd1). This file contains the metadata for your module and requires several fields to be updated to meet PSGallery requirements. All the information displayed on PSGallery is retrieved from the content of the .psd1 file. Key fields to update include:\nModule Name Version (using Semantic Versioning) Tags (for visibility and searchability) Project URI (optional but recommended) You can create a template manifest file using the New-ModuleManifest cmdlet. This template serves as a reference for all the fields you can update. It\u0026rsquo;s best to populate as much information as possible to ensure your module is well-documented and easily discoverable.\nWrite Help Local modules often don\u0026rsquo;t receive much attention when it comes to documentation, as they are typically used by you or a small team nearby. However, a complete stranger on the other side of the world won\u0026rsquo;t have any idea how to run or use the commands in your module. Therefore, it\u0026rsquo;s crucial to write detailed help for each function, complete with examples. There are two key places where you can provide this explanation for your module:\nComment-Based Help: Used to provide detailed help for individual commands within the module. Repository README Page: Contains descriptions of the module, its approach, design decisions, and roadmap. Module Structure This is optional initially, but quickly becomes crucial, especially when others want to contribute. If your entire module is contained within a single psm1 file, understanding and contributing to it becomes nearly impossible. There are several methods and best practices for structuring a module, such as this one by Kevin Marauette, that help create readable and easy-to-collaborate modules.\nI have a Module built just to make building module simple and efficient. Check out ModuleTools. You can download the ModuleTools from [PSGallery](https://www.powershellgallery.com/packages/ModuleTools.\nInstall-Module -Name ModuleTools Code Quality and Testing Parameter naming conventions, function naming conventions, and even the content in your help files become crucial when sharing code with others. Writing code that is easy for others to read also makes it easier for you to revisit and understand years later.\nTesting is initially optional but becomes crucial when ensuring your module doesn\u0026rsquo;t break on other machines. Pester tests simplify running tests (easy to run as CI) and help ensure that adding or modifying code doesn\u0026rsquo;t affect existing functions.\nPester syntax might seem daunting to get started, but once you get the basics it becomes as simple as any PowerShell script.\nPublish Locally Set up a local file share-based Private NuGet repository on your machine and practice publishing to it. This will help you become proficient before you\u0026rsquo;re ready to publish to PSGallery.\nConclusion In conclusion, publishing your PowerShell module to PSGallery opens up a world of opportunities. By following best practices in module development, writing clear documentation, and incorporating testing, you not only enhance your module\u0026rsquo;s usability but also contribute positively to the community. Embrace the journey from writing scripts to creating modulesâ€”it\u0026rsquo;s a rewarding experience that strengthens your coding skills and fosters collaboration with others worldwide. Start sharing your creations today and see how your contributions can make a difference. Happy coding!\n","permalink":"https://blog.belibug.com/post/ps-psgallery/","summary":"From Script to Shared Success, Publishing on the PowerShell Gallery","title":"Publishing Module to PSGallery"},{"content":"There is no shortage of modules in the PowerShell Gallery for building modules. In fact, there are at least a dozen actively managed modules capable of building complex modules. So, you might ask, why choose ModuleTools and what makes it special? Allow me to explain.\nBuilding modules doesn\u0026rsquo;t have to be complex or an all-or-nothing process. While I have drawn a lot of inspiration from InvokeBuild and the Sampler module builder, they are overly complex and have a steep learning curve. They introduce their own assert, exec, and requires syntax that you need to learn. They depend on several other Modules (like psake, plaster).\nIntroducing ModuleTools ModuleTools employs a straightforward structure and a single data file (project.json) to manage the entire module development process. It allows you to build, run Pester tests, or perform semantic version upgrades with ease. You can customize its usage by selecting only the tasks you need, such as invoking builds while skipping tests. Additionally, the same commands work seamlessly for both local and pipeline builds.\nIt is entirely self-contained, eliminating the need for scaffolding tools (like Plaster), build tools (like Psake), or the maintenance of non-functional helper files (like psd1 and build.ps1).\nFind the source code for SecretBackup module on GitHub which will be used for reference in below examples.\nWhy Build at all? If you have built module yourself or know what you are doing, skip directly to next section\nUnlike other compiled languages, there is no formal concept of a \u0026ldquo;build\u0026rdquo; in PowerShell development. However, creating a well-organized and easy-to-manage PowerShell module requires a certain structure and organization. Build tools help achieve this by generating the necessary structure with ease.\nThe organizational structure is the most compelling reason to have a build mechanism. Instead of cramming hundreds of lines of code into a single psm1 file, it\u0026rsquo;s more efficient to give each function its own file.\nThe idea is that each file contains one function, and each function performs a single task. This approach makes files and functions easier to manage and control through versioning.\nGetting Started with ModuleTools New-MTModule is all you need to set up your project. In fewer than six interactive steps, you\u0026rsquo;ll be ready to start writing beautiful modules. Below is a screenshot of setting up a test module project.\nProject JSON file This file contains key information about the project, including everything from the module\u0026rsquo;s GUID to the Pester configuration. It is created automatically with New-MTModule, or you can copy a sample file from here.\n{ \u0026#34;ProjectName\u0026#34;: \u0026#34;ModuleName\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Description of Module\u0026#34;, \u0026#34;Version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;Manifest\u0026#34;: { \u0026#34;Author\u0026#34;: \u0026#34;Manjunath Beli\u0026#34;, \u0026#34;PowerShellHostVersion\u0026#34;: \u0026#34;7.4\u0026#34;, \u0026#34;GUID\u0026#34;: \u0026#34;Use New-Guid to generate guid\u0026#34;, \u0026#34;Tags\u0026#34;: [], \u0026#34;ProjecUri\u0026#34;: \u0026#34;\u0026#34; } } Folder Structure If you used the New-MTModule command the folder structure is already setup for you. If you like doing it manually, these are important folders\nEach folder serves a purpose\nFolder Purpose Root\\project.json This is main project info file in json format Src\\private Functions required for module but not exposed to user Src\\public Functions that are exposed in module Src\\resources Any file you want to ship with module (like config.ini image.jpg) tests all the pester tests dist auto generated, the output of ModuleTools invoke build command For instance, this is folder structure in one of my module SecretBackup\nPowerShell Functions I like to break my functions into simple, one-task-only scripts. The name of the function doesn\u0026rsquo;t matter, but each file should contain only one top level function. Everything in the public folder gets exported as module commands, while everything in the private folder is accessible within the module but not exposed to the user.\nSample Function\n# File SayHello.ps1 function Write-Greetings { Write-Host \u0026#34;Hello Stranger!\u0026#34; } Name of the file is not important, ensure the content of file has one top level function only.\nBuild Building a module is as simple as Invoke-MTBuild. Use -Verbose if you want to see more details during build. It takes less than a second to build.\nTests You can also easily run Tests using Invoke-MTTest. Ensure all your tests are in tests folder in root directory of project.\nAll the pester configuration can be stored in project.json which makes running pester test easy and consistent.\nOutput Output files are kept in the dist folder located in the project\u0026rsquo;s root directory. Each time you run a build, this directory is cleaned up, and the module is built from scratch.\nAutomation All configuration details are stored in project.json, which is easy to parse and use in automation. The module also includes the Get-MTProjectInfo command, which provides additional properties of the module, allowing you to easily incorporate them into Pester tests and automation.\nAll commands are terminating on error, which means you can run them sequentially for easy automation.\n# File run.ps1 ## Build Module Invoke-MTBuild ## Perform Tests Invoke-MTTest ## Publish Module Publish-PSResource -Repository PrivateOwn -path ./dist/SecretBackup This simple flow ensures that the module is published (step-3) only if the Build (step-1) and Tests (step-2) run without errors.\nGithub Actions Module builds can be easily automated using GitHub Actions since all the necessary build commands are contained within the single ModuleTools module. Simply install the module, import it, run the build, and you\u0026rsquo;re good to go.\nSample github action flow, using no 3rd party actions, on a ubuntu host.\nname: Publish to Packages # Controls when the workflow will run on: workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Install ModuleTools module form PSGallery run: Install-PSResource -Repository PSGallery -Name ModuleTools -TrustRepository shell: pwsh - name: Build Module run: Invoke-MTBuild -Verbose shell: pwsh - name: Run Pester Tests run: Invoke-MTTest shell: pwsh - name: Publish Package to Github run: Publish-PSResource -Path ./dist/ModuleTools -Repository PSGallery -ApiKey $Env:ApiKey env: ApiKey: ${{ secrets.PSGALLERY_API }} shell: pwsh Conclusion In conclusion, ModuleTools simplifies PowerShell module development by offering a straightforward approach to organizing functions into single-task scripts, managed through a unified project.json configuration.\nWith ModuleTools, you can easily transform your scattered or lengthy scripts into the well-structured modules you\u0026rsquo;ve always aimed for.\nGot ideas or feedback? Drop them in github issues/discussion! Let\u0026rsquo;s make building PowerShell modules easier and more awesome together.\n","permalink":"https://blog.belibug.com/post/ps-modulebuild/","summary":"From Scattered Scripts to Organized Modules,  Master the craft of creating efficient and reusable code","title":"Simplify PowerShell Module Development with ModuleTools"},{"content":" In the ever-evolving digital landscape, crafting clear and concise content is more crucial than ever. But have you ever felt bogged down by clunky formatting tools or frustrated with endless copy-pasting between writing platforms?\nEnter Markdown, a revolutionary yet straightforward markup language that empowers you to write beautifully formatted text without the hassle.\nWhat\u0026rsquo;s Markdown Markdown is a lightweight markup language that you can use to add formatting elements to plaintext text documents. Created by John Gruber in 2004, Markdown is now one of the world\u0026rsquo;s most popular markup languages.\nWhy Markdown is Magical? Markdown\u0026rsquo;s magic lies in its simplicity. It uses plain text characters and symbols to define formatting elements like headings, bold text, italics, and lists. This eliminates the need for complex menus or endless buttons, allowing you to focus on your content.\nThere are endless guides all over internet on how to write using markdown syntax (reference links at end of article). Here are the basics you need to know in three crisp precise points\nSyntax Description # For heading - For bullet points ![ImageName](Image.jpg) for Image Is it really that simple? Of course not, I had to over simplify it to make a point but this should be sufficient to get 70% of job done.\nModern text processors like OneNote and MS Word offer a vast array of formatting options, letting you create visually stunning documents with a click of a button. They\u0026rsquo;ve become incredibly powerful, thanks to advancements in hardware and processing power. But that power comes at a cost - complexity.\nMarkdown on other hand is simple plain text.\nThis entire blog article is written in markdown\nWhy have I not heard about Markdown before? Markdown has taken the digital world by storm, praised for its simplicity and efficiency. But despite its undeniable strengths, it hasn\u0026rsquo;t quite achieved universal popularity. Particularly for non-technical users, Markdown can present a bit of a hurdle. Here is why:\nLearning curve: symbols and codes are complicated compared to menus and buttons GUI Tools: Unlike WYSIWYG (What You See Is What You Get) editors like MS Word, Markdown offers no live preview of formatting (generally) Limited Design Options: Markdown excels at basic formatting, but complex layouts or design elements are beyond its scope (by design) Niche appeal: while its powerful for developers and IT engineers, Markdown core functionality does not resonate with everyone (yet!) How to bridge that gap? Did you know? Popular chat apps like Teams, Zoom, Slack and WhatsApp allow you to use Markdown for basic formatting within your messages.\nThis is how one can overcome most of the above listed challenges,\nLearning Curve and GUI Tools: Several tool overs menu/buttons and gui interface to build markdown text. This significantly helps understand markdown syntax and ease transition. Limited Design Options: There are several extended Markdown Syntax to address some of design challenges and introduce new design elements like callouts and foldable content. Only for Developers: This is no longer valid as more and more applications are incorporating markdown syntax and formatting in their tools. So how do one get started? Start Small: You don\u0026rsquo;t need advanced editors and software to get started. Begin with an online Markdown editor to familiarize yourself with the basics. There are numerous such editors available; my personal favorite is Dillinger Choose an Editor: There are several WYSIWYG editors you can install on your device that make it easy to learn Markdown syntax. The syntax is so simple that you will quickly become accustomed to using Markdown, even in Notepad. My personal favorite is Obsidian. Keep Practicing: I use Markdown for everything, including personal notes, meeting minutes, project notes, to-do lists, and journaling. It\u0026rsquo;s a lightweight, versatile format that\u0026rsquo;s easy to move across different platforms. The best part is that I\u0026rsquo;m not tied to any specific software or concerned about potential subscription fees for accessing my data. Keep following this blog for more markdown related tips and tricks. See you in next one!\n","permalink":"https://blog.belibug.com/post/markdown-magic/","summary":"The Essential Writing Tool for the Digital Age, Simplify Your Writing Workflow!","title":"The Power of Markdown for Everyone"}]